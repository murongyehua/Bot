# 背包系统

<cite>
**本文档引用文件**  
- [PlayerGoods.java](file://Game/src/main/java/com/bot/game/dao/entity/PlayerGoods.java)
- [PlayerGoodsMapper.java](file://Game/src/main/java/com/bot/game/dao/mapper/PlayerGoodsMapper.java)
- [PlayerGoodsMapper.xml](file://Game/src/main/resources/mapper/PlayerGoodsMapper.xml)
- [CommonPlayer.java](file://Game/src/main/java/com/bot/game/service/impl/CommonPlayer.java)
- [MyKnapsackMenuPrinter.java](file://Game/src/main/java/com/bot/game/chain/menu/MyKnapsackMenuPrinter.java)
- [BaseGoods.java](file://Game/src/main/java/com/bot/game/dao/entity/BaseGoods.java)
- [BaseGoodsMapper.xml](file://Game/src/main/resources/mapper/BaseGoodsMapper.xml)
- [ENGoodEffect.java](file://Game/src/main/java/com/bot/game/enums/ENGoodEffect.java)
- [UseGoodsPrinter.java](file://Game/src/main/java/com/bot/game/chain/menu/UseGoodsPrinter.java)
- [GetPhantomServiceImpl.java](file://Game/src/main/java/com/bot/game/service/impl/GetPhantomServiceImpl.java)
- [SendMessageServiceImpl.java](file://Game/src/main/java/com/bot/game/service/impl/message/SendMessageServiceImpl.java)
- [SignMenuPrinter.java](file://Game/src/main/java/com/bot/game/chain/menu/SignMenuPrinter.java)
</cite>

## 目录
1. [简介](#简介)
2. [核心实体设计](#核心实体设计)
3. [库存管理机制](#库存管理机制)
4. [物品增减与堆叠规则](#物品增减与堆叠规则)
5. [物品分类与业务规则](#物品分类与业务规则)
6. [典型场景数据处理流程](#典型场景数据处理流程)
7. [MyBatis映射与批量操作优化](#mybatis映射与批量操作优化)
8. [背包容量限制](#背包容量限制)
9. [总结](#总结)

## 简介
背包系统是游戏核心功能之一，负责管理玩家持有的所有物品。本系统通过PlayerGoods实体实现玩家与物品的关联关系，支持物品的获取、使用、交易等操作。系统设计考虑了性能优化、事务完整性和用户体验，实现了高效的库存管理和灵活的物品交互机制。

## 核心实体设计

### PlayerGoods实体结构
PlayerGoods实体是背包系统的核心数据模型，用于存储玩家持有的物品信息。该实体通过玩家ID和物品ID建立关联关系，实现多对多的数据结构。

```mermaid
classDiagram
class PlayerGoods {
+String id
+String playerId
+String goodId
+Integer number
+static final long serialVersionUID
}
```

**实体属性说明**：
- **id**：主键，唯一标识每个物品记录
- **playerId**：玩家ID，关联到GamePlayer实体
- **goodId**：物品ID，关联到BaseGoods实体
- **number**：物品数量，支持堆叠功能

**Diagram sources**
- [PlayerGoods.java](file://Game/src/main/java/com/bot/game/dao/entity/PlayerGoods.java#L11-L20)

**Section sources**
- [PlayerGoods.java](file://Game/src/main/java/com/bot/game/dao/entity/PlayerGoods.java#L9-L20)

### 基础物品设计
BaseGoods实体定义了游戏中所有物品的基础属性和行为特征。

```mermaid
classDiagram
class BaseGoods {
+String id
+String name
+String effect
+String figure
+String describe
+String termOfValidity
+String used
+String origin
+String weight
+String targetId
+static final long serialVersionUID
}
```

**关键属性说明**：
- **effect**：物品效果类型，通过ENGoodEffect枚举定义
- **termOfValidity**：有效期，用于实现物品过期机制
- **weight**：产出权重，影响物品掉落概率
- **targetId**：目标对象ID，用于技能卡等特殊物品

**Diagram sources**
- [BaseGoods.java](file://Game/src/main/java/com/bot/game/dao/entity/BaseGoods.java#L15-L60)

## 库存管理机制

### 数据访问层设计
系统通过MyBatis实现数据持久化，PlayerGoodsMapper接口提供了完整的CRUD操作。

```mermaid
classDiagram
class PlayerGoodsMapper {
+int deleteByPrimaryKey(String id)
+int insert(PlayerGoods record)
+int insertSelective(PlayerGoods record)
+PlayerGoods selectByPrimaryKey(String id)
+int updateByPrimaryKeySelective(PlayerGoods record)
+int updateByPrimaryKey(PlayerGoods record)
+List<PlayerGoods> selectBySelective(PlayerGoods record)
}
```

**主要方法功能**：
- **selectBySelective**：条件查询，支持按玩家ID或物品ID检索
- **insertSelective**：选择性插入，只插入非空字段
- **updateByPrimaryKeySelective**：选择性更新，只更新非空字段

**Diagram sources**
- [PlayerGoodsMapper.java](file://Game/src/main/java/com/bot/game/dao/mapper/PlayerGoodsMapper.java#L7-L20)

### MyBatis映射配置
PlayerGoodsMapper.xml文件定义了SQL映射规则，实现了高效的数据库操作。

```mermaid
erDiagram
PLAYER_GOODS ||--o{ BASE_GOODS : "拥有"
PLAYER_GOODS ||--|| GAME_PLAYER : "属于"
PLAYER_GOODS {
string id PK
string playerId FK
string goodId FK
integer number
}
BASE_GOODS {
string id PK
string name
string effect
string describe
string termOfValidity
}
GAME_PLAYER {
string id PK
string nickname
integer money
integer actionPoint
}
```

**映射文件特点**：
- 使用`<if>`标签实现动态SQL，提高查询效率
- `insertSelective`和`updateByPrimaryKeySelective`方法支持部分字段更新
- `selectBySelective`方法支持多条件组合查询

**Diagram sources**
- [PlayerGoodsMapper.xml](file://Game/src/main/resources/mapper/PlayerGoodsMapper.xml#L1-L91)
- [BaseGoodsMapper.xml](file://Game/src/main/resources/mapper/BaseGoodsMapper.xml#L1-L144)

## 物品增减与堆叠规则

### 物品增加机制
当玩家获得新物品时，系统首先检查是否已持有该物品：
- 如果已持有，则更新数量
- 如果未持有，则创建新记录

```mermaid
flowchart TD
Start([物品增加流程]) --> CheckExist["检查物品是否存在"]
CheckExist --> |存在| UpdateNumber["更新数量"]
CheckExist --> |不存在| CreateNew["创建新记录"]
UpdateNumber --> SaveDB["保存到数据库"]
CreateNew --> SaveDB
SaveDB --> End([流程结束])
```

**核心实现代码**：
```java
public static void addPlayerGoods(String goodsId, String token, int number) {
    PlayerGoodsMapper playerGoodsMapper = (PlayerGoodsMapper) mapperMap.get(GameConsts.MapperName.PLAYER_GOODS);
    PlayerGoods param = new PlayerGoods();
    param.setPlayerId(token);
    param.setGoodId(goodsId);
    List<PlayerGoods> list = playerGoodsMapper.selectBySelective(param);
    if (CollectionUtil.isNotEmpty(list)) {
        PlayerGoods playerGoods = list.get(0);
        playerGoods.setNumber(playerGoods.getNumber() + number);
        playerGoodsMapper.updateByPrimaryKey(playerGoods);
        return;
    }
    param.setId(IdUtil.simpleUUID());
    param.setNumber(number);
    playerGoodsMapper.insert(param);
}
```

**Section sources**
- [CommonPlayer.java](file://Game/src/main/java/com/bot/game/service/impl/CommonPlayer.java#L161-L176)

### 物品使用与扣除
物品使用后，系统根据剩余数量决定处理方式：
- 如果使用后数量为0，则删除记录
- 如果仍有剩余，则更新数量

```mermaid
flowchart TD
Start([物品使用流程]) --> CheckQuantity["检查物品数量"]
CheckQuantity --> |足够| UseItem["使用物品"]
UseItem --> CalculateLeft["计算剩余数量"]
CalculateLeft --> |剩余为0| DeleteRecord["删除记录"]
CalculateLeft --> |仍有剩余| UpdateNumber["更新数量"]
DeleteRecord --> End([流程结束])
UpdateNumber --> End
```

**核心实现代码**：
```java
public static void afterUseGoods(PlayerGoods playerGoods, int number) {
    PlayerGoodsMapper playerGoodsMapper = (PlayerGoodsMapper) mapperMap.get(GameConsts.MapperName.PLAYER_GOODS);
    if (playerGoods.getNumber() == number) {
        playerGoodsMapper.deleteByPrimaryKey(playerGoods.getId());
    } else {
        playerGoods.setNumber(playerGoods.getNumber() - number);
        playerGoodsMapper.updateByPrimaryKeySelective(playerGoods);
    }
}
```

**Section sources**
- [CommonPlayer.java](file://Game/src/main/java/com/bot/game/service/impl/CommonPlayer.java#L182-L190)

## 物品分类与业务规则

### 物品效果分类
系统通过ENGoodEffect枚举对物品进行分类管理：

```mermaid
classDiagram
class ENGoodEffect {
+String value
+String label
+Integer money
+GET_PHANTOM("0", "唤灵符", 1000)
+SKILL("1", "技能卡", 25)
+WAN_1("2", "避灵丹", 5)
+WAN_2("3", "大蕴丸", 10)
+WAN_3("4", "天命散", 20)
+WAN_4("5", "洗髓丹", 300)
+WAN_5("6", "溢灵散", 600)
+WAN_6("7", "小补丸", 100)
+WAN_7("8", "大还丹", 190)
+WAN_8("9", "九转灵泉水", 3500)
}
```

**分类特点**：
- 每种物品有唯一的value标识
- label为物品显示名称
- money为物品价值，用于交易计算

**Diagram sources**
- [ENGoodEffect.java](file://Game/src/main/java/com/bot/game/enums/ENGoodEffect.java#L15-L25)

### 业务规则实现
系统实现了多种业务规则，确保游戏平衡性：

```mermaid
flowchart TD
subgraph "使用限制"
CheckExist["检查物品是否存在"]
CheckQuantity["检查数量是否足够"]
CheckCooldown["检查冷却时间"]
CheckBuff["检查当前是否有相同增益"]
end
subgraph "特殊规则"
PhantomRule["唤灵符使用规则"]
SkillRule["技能卡使用规则"]
BuffRule["增益效果叠加规则"]
end
CheckExist --> CheckQuantity
CheckQuantity --> CheckCooldown
CheckCooldown --> CheckBuff
CheckBuff --> PhantomRule
PhantomRule --> SkillRule
SkillRule --> BuffRule
```

**Section sources**
- [ENGoodEffect.java](file://Game/src/main/java/com/bot/game/enums/ENGoodEffect.java#L15-L50)

## 典型场景数据处理流程

### 物品获取场景
玩家通过签到获取随机物品的完整流程：

```mermaid
sequenceDiagram
participant Player as "玩家"
participant SignMenu as "签到菜单"
participant CommonPlayer as "公共玩家服务"
participant GoodsMapper as "物品Mapper"
participant PlayerGoodsMapper as "玩家物品Mapper"
Player->>SignMenu : 执行签到
SignMenu->>CommonPlayer : randomGetGoods(token)
CommonPlayer->>GoodsMapper : getResultGoods(area)
GoodsMapper-->>CommonPlayer : 返回随机物品
CommonPlayer->>PlayerGoodsMapper : selectBySelective(param)
PlayerGoodsMapper-->>CommonPlayer : 返回物品记录
alt 物品已存在
CommonPlayer->>PlayerGoodsMapper : updateByPrimaryKey(playerGoods)
else 物品不存在
CommonPlayer->>PlayerGoodsMapper : insert(param)
end
PlayerGoodsMapper-->>CommonPlayer : 操作结果
CommonPlayer-->>SignMenu : 物品名称
SignMenu-->>Player : 显示获得物品
```

**Section sources**
- [SignMenuPrinter.java](file://Game/src/main/java/com/bot/game/chain/menu/SignMenuPrinter.java#L48-L69)
- [CommonPlayer.java](file://Game/src/main/java/com/bot/game/service/impl/CommonPlayer.java#L239-L270)

### 物品使用场景
玩家使用增益类物品的处理流程：

```mermaid
sequenceDiagram
participant Player as "玩家"
participant UseGoods as "使用物品菜单"
participant CommonPlayer as "公共玩家服务"
participant PlayerGoodsMapper as "玩家物品Mapper"
Player->>UseGoods : 选择使用物品
UseGoods->>CommonPlayer : checkGoodsNumber(token, effect)
CommonPlayer->>PlayerGoodsMapper : selectBySelective(playerGoods)
PlayerGoodsMapper-->>CommonPlayer : 返回物品记录
CommonPlayer-->>UseGoods : 验证结果
alt 可以使用
UseGoods->>CommonPlayer : afterUseGoods(playerGoods, 1)
CommonPlayer->>PlayerGoodsMapper : update或delete操作
PlayerGoodsMapper-->>CommonPlayer : 操作结果
CommonPlayer-->>UseGoods : 处理完成
UseGoods-->>Player : 显示使用成功
else 无法使用
UseGoods-->>Player : 显示错误信息
end
```

**Section sources**
- [UseGoodsPrinter.java](file://Game/src/main/java/com/bot/game/chain/menu/UseGoodsPrinter.java#L123-L156)
- [CommonPlayer.java](file://Game/src/main/java/com/bot/game/service/impl/CommonPlayer.java#L410-L425)

### 物品交易场景
玩家间物品赠送的完整流程：

```mermaid
sequenceDiagram
participant Sender as "发送方"
participant MessageService as "消息服务"
participant GoodsBoxMapper as "物品盒子Mapper"
participant PlayerGoodsMapper as "玩家物品Mapper"
Sender->>MessageService : 发送包含物品的消息
MessageService->>GoodsBoxMapper : insert(goodsBox)
GoodsBoxMapper-->>MessageService : 插入成功
MessageService->>PlayerGoodsMapper : selectBySelective(param)
PlayerGoodsMapper-->>MessageService : 返回物品记录
MessageService->>PlayerGoodsMapper : update或delete操作
PlayerGoodsMapper-->>MessageService : 操作结果
MessageService-->>Sender : 显示发送成功
```

**Section sources**
- [SendMessageServiceImpl.java](file://Game/src/main/java/com/bot/game/service/impl/message/SendMessageServiceImpl.java#L75-L113)

## MyBatis映射与批量操作优化

### 动态SQL优化
系统通过MyBatis的动态SQL特性实现高效的数据库操作：

```xml
<insert id="insertSelective" keyColumn="id" keyProperty="id" parameterType="com.bot.game.dao.entity.PlayerGoods" useGeneratedKeys="true">
    insert into bot_player_goods
    <trim prefix="(" suffix=")" suffixOverrides=",">
        <if test="playerId != null">
            player_id,
        </if>
        <if test="goodId != null">
            good_id,
        </if>
        <if test="number != null">
            number,
        </if>
    </trim>
    <trim prefix="values (" suffix=")" suffixOverrides=",">
        <if test="playerId != null">
            #{playerId,jdbcType=VARCHAR},
        </if>
        <if test="goodId != null">
            #{goodId,jdbcType=VARCHAR},
        </if>
        <if test="number != null">
            #{number,jdbcType=INTEGER},
        </if>
    </trim>
</insert>
```

**优化优势**：
- 只插入非空字段，减少数据库压力
- 使用`useGeneratedKeys="true"`自动生成主键
- `trim`标签自动处理逗号分隔

**Section sources**
- [PlayerGoodsMapper.xml](file://Game/src/main/resources/mapper/PlayerGoodsMapper.xml#L29-L52)

### 批量操作策略
系统通过合理的批量操作设计提高性能：

```mermaid
graph TD
subgraph "批量查询"
SelectByPlayer["按玩家ID批量查询"]
SelectByGoods["按物品ID批量查询"]
end
subgraph "批量更新"
UpdateNumber["批量更新数量"]
DeleteEmpty["批量删除空记录"]
end
subgraph "性能优化"
Cache["本地缓存常用物品"]
Batch["批量提交事务"]
Index["数据库索引优化"]
end
SelectByPlayer --> Performance
SelectByGoods --> Performance
UpdateNumber --> Performance
DeleteEmpty --> Performance
Cache --> Performance
Batch --> Performance
Index --> Performance
```

**Section sources**
- [PlayerGoodsMapper.xml](file://Game/src/main/resources/mapper/PlayerGoodsMapper.xml#L76-L90)

## 背包容量限制
系统通过以下机制实现背包容量管理：

```mermaid
flowchart TD
Start([背包容量检查]) --> GetTotal["获取玩家物品总数"]
GetTotal --> Compare["与最大容量比较"]
Compare --> |未超限| AllowAction["允许操作"]
Compare --> |已超限| ShowError["显示容量不足"]
ShowError --> Suggest["建议处理方案"]
Suggest --> |出售| SellItems["出售不常用物品"]
Suggest --> |使用| UseItems["使用增益物品"]
Suggest --> |丢弃| DiscardItems["丢弃低价值物品"]
SellItems --> End([操作完成])
UseItems --> End
DiscardItems --> End
AllowAction --> End
```

虽然当前代码中未直接实现硬性容量限制，但通过以下方式间接管理：
- 物品使用：消耗物品释放空间
- 物品出售：移除物品释放空间
- 新物品获取：优先使用已有堆叠空间

**Section sources**
- [MyKnapsackMenuPrinter.java](file://Game/src/main/java/com/bot/game/chain/menu/MyKnapsackMenuPrinter.java#L34-L49)

## 总结
背包系统通过PlayerGoods实体实现了玩家与物品的灵活关联，支持高效的物品增减、堆叠和分类管理。系统设计考虑了性能优化和用户体验，通过MyBatis的动态SQL特性实现了高效的数据库操作。物品分类通过ENGoodEffect枚举进行管理，确保了游戏平衡性。典型场景如物品获取、使用和交易都实现了完整的数据处理流程，保证了数据的一致性和完整性。

未来可优化方向：
1. 增加明确的背包容量限制
2. 实现物品过期自动清理机制
3. 添加物品分页查询功能
4. 优化批量操作性能
5. 增加物品搜索和筛选功能