# 游戏状态管理

<cite>
**本文档引用的文件**
- [ENGameMode.java](file://Life/src/main/java/com/bot/life/enums/ENGameMode.java)
- [LifeGameStatus.java](file://Life/src/main/java/com/bot/life/dao/entity/LifeGameStatus.java)
- [LifeHandlerImpl.java](file://Life/src/main/java/com/bot/life/service/impl/LifeHandlerImpl.java)
- [LifeGameStatusMapper.java](file://Life/src/main/java/com/bot/life/dao/mapper/LifeGameStatusMapper.java)
- [LifeGameStatusMapper.xml](file://Life/src/main/resources/mapper/LifeGameStatusMapper.xml)
- [BattleContext.java](file://Life/src/main/java/com/bot/life/dto/BattleContext.java)
- [BattleServiceImpl.java](file://Life/src/main/java/com/bot/life/service/impl/BattleServiceImpl.java)
</cite>

## 目录
1. [概述](#概述)
2. [ENGameMode状态机设计](#engamemode状态机设计)
3. [LifeGameStatus实体结构](#lifegamestatus实体结构)
4. [状态转换机制](#状态转换机制)
5. [核心状态处理方法](#核心状态处理方法)
6. [状态持久化策略](#状态持久化策略)
7. [数据同步机制](#数据同步机制)
8. [状态转换图](#状态转换图)
9. [开发者指南](#开发者指南)
10. [故障排除](#故障排除)

## 概述

修仙游戏采用基于状态机的游戏状态管理模式，通过ENGameMode枚举定义了五个主要游戏状态：NOT_ENTERED（未进入）、PREPARE（预备状态）、IN_GAME（正式游戏）、GHOST_MARKET（鬼市）和BATTLE（战斗中）。系统通过LifeGameStatus实体维护每个用户的完整游戏状态，并实现了完善的状态持久化和数据同步机制。

## ENGameMode状态机设计

### 状态定义

ENGameMode枚举定义了游戏的五种核心状态：

```mermaid
classDiagram
class ENGameMode {
<<enumeration>>
+int code
+String desc
+getCode() int
+getDesc() String
+getByCode(int) ENGameMode
}
class NOT_ENTERED {
+code : 0
+desc : "未进入"
}
class PREPARE {
+code : 1
+desc : "预备状态"
}
class IN_GAME {
+code : 2
+desc : "正式游戏"
}
class GHOST_MARKET {
+code : 3
+desc : "鬼市"
}
class BATTLE {
+code : 4
+desc : "战斗中"
}
ENGameMode <|-- NOT_ENTERED
ENGameMode <|-- PREPARE
ENGameMode <|-- IN_GAME
ENGameMode <|-- GHOST_MARKET
ENGameMode <|-- BATTLE
```

**图表来源**
- [ENGameMode.java](file://Life/src/main/java/com/bot/life/enums/ENGameMode.java#L6-L37)

### 状态特性

| 状态 | 编码 | 描述 | 主要功能 |
|------|------|------|----------|
| NOT_ENTERED | 0 | 未进入 | 初始状态，等待用户输入"浮生卷" |
| PREPARE | 1 | 预备状态 | 等待用户确认进入游戏 |
| IN_GAME | 2 | 正式游戏 | 主游戏界面，支持所有功能 |
| GHOST_MARKET | 3 | 鬼市 | 商业交易界面 |
| BATTLE | 4 | 战斗中 | 战斗过程状态 |

**章节来源**
- [ENGameMode.java](file://Life/src/main/java/com/bot/life/enums/ENGameMode.java#L7-L11)

## LifeGameStatus实体结构

### 数据模型设计

LifeGameStatus实体是游戏状态管理的核心数据结构，包含以下关键字段：

```mermaid
classDiagram
class LifeGameStatus {
+Long id
+String userId
+Integer gameMode
+String currentMenu
+String contextData
+Date createTime
+Date updateTime
+getGameMode() Integer
+setGameMode(Integer) void
+getCurrentMenu() String
+setCurrentMenu(String) void
+getContextData() String
+setContextData(String) void
}
class GameStatusFields {
<<annotation>>
+gameMode : 游戏模式编码
+currentMenu : 当前菜单状态
+contextData : JSON格式上下文数据
+createTime : 创建时间
+updateTime : 最后更新时间
}
LifeGameStatus --> GameStatusFields : 包含
```

**图表来源**
- [LifeGameStatus.java](file://Life/src/main/java/com/bot/life/dao/entity/LifeGameStatus.java#L11-L20)

### 字段详解

| 字段名 | 类型 | 描述 | 用途 |
|--------|------|------|------|
| id | Long | 主键标识 | 数据库唯一标识 |
| userId | String | 用户ID | 关联用户身份 |
| gameMode | Integer | 游戏模式 | 当前游戏状态编码 |
| currentMenu | String | 当前菜单 | 子功能菜单状态 |
| contextData | String | 上下文数据 | JSON格式的动态数据 |
| createTime | Date | 创建时间 | 数据创建时间戳 |
| updateTime | Date | 更新时间 | 数据最后修改时间 |

**章节来源**
- [LifeGameStatus.java](file://Life/src/main/java/com/bot/life/dao/entity/LifeGameStatus.java#L13-L19)

## 状态转换机制

### 转换流程

游戏状态转换遵循严格的流程控制，确保状态的一致性和数据完整性：

```mermaid
flowchart TD
Start([用户输入]) --> CheckMode{检查当前状态}
CheckMode --> |NOT_ENTERED| GameEntry[handleGameEntry]
CheckMode --> |PREPARE| PrepareMode[handlePrepareMode]
CheckMode --> |IN_GAME| InGameMode[handleInGameMode]
CheckMode --> |GHOST_MARKET| GhostMarket[handleGhostMarketMode]
CheckMode --> |BATTLE| BattleMode[handleBattleMode]
GameEntry --> Prepare[设置PREPARE状态]
Prepare --> WaitConfirm[等待用户确认]
WaitConfirm --> Confirm{用户确认?}
Confirm --> |是| EnterGame[设置IN_GAME状态]
Confirm --> |否| Cancel[设置NOT_ENTERED状态]
InGameMode --> CheckAction{检查用户动作}
CheckAction --> |战斗| Battle[设置BATTLE状态]
CheckAction --> |鬼市| GhostMarketMode[设置GHOST_MARKET状态]
CheckAction --> |退出| Exit[重置状态]
Battle --> BattleEnd{战斗结束?}
BattleEnd --> |胜利/失败| Cleanup[清理战斗状态]
Cleanup --> ReturnGame[返回IN_GAME状态]
GhostMarket --> MarketEnd{退出鬼市?}
MarketEnd --> |是| ReturnGame
MarketEnd --> |否| ContinueMarket[继续鬼市功能]
Exit --> Reset[重置为NOT_ENTERED]
```

**图表来源**
- [LifeHandlerImpl.java](file://Life/src/main/java/com/bot/life/service/impl/LifeHandlerImpl.java#L147-L166)

### 转换条件

状态转换由以下条件触发：

1. **用户输入触发**：用户发送特定命令
2. **系统事件触发**：战斗结束、角色创建完成
3. **业务逻辑触发**：功能模块切换
4. **异常情况触发**：状态异常时的恢复机制

**章节来源**
- [LifeHandlerImpl.java](file://Life/src/main/java/com/bot/life/service/impl/LifeHandlerImpl.java#L173-L218)

## 核心状态处理方法

### handleGameEntry方法

处理游戏入口状态，引导用户进入游戏准备阶段：

```mermaid
sequenceDiagram
participant User as 用户
participant Handler as LifeHandlerImpl
participant Status as LifeGameStatus
participant Image as ImageService
User->>Handler : 发送"浮生卷"
Handler->>Handler : 验证输入内容
Handler->>Status : 设置gameMode=PREPARE
Handler->>Status : 更新updateTime
Handler->>Status : 调用updateByPrimaryKey
Handler->>Image : 生成欢迎图片
Image-->>Handler : 返回图片路径
Handler-->>User : 发送欢迎消息
```

**图表来源**
- [LifeHandlerImpl.java](file://Life/src/main/java/com/bot/life/service/impl/LifeHandlerImpl.java#L173-L194)

### handlePrepareMode方法

处理游戏准备状态，管理用户确认流程：

- **确认进入**：用户发送"1" → 设置IN_GAME状态
- **取消进入**：用户发送其他内容 → 设置NOT_ENTERED状态
- **状态验证**：检查角色是否存在，决定后续流程

### handleInGameMode方法

处理正式游戏状态，管理所有游戏功能：

```mermaid
flowchart TD
InGame[IN_GAME状态] --> CheckExit{退出命令?}
CheckExit --> |是| Exit[退出游戏]
CheckExit --> |否| CheckPlayer{角色存在?}
CheckPlayer --> |否| CharCreate[角色创建流程]
CheckPlayer --> |是| CheckMenu{有当前菜单?}
CheckMenu --> |TELEPORT_SELECT| Teleport[传送选择]
CheckMenu --> |其他| NormalFlow[常规游戏流程]
NormalFlow --> CheckCommands{检查命令类型}
CheckCommands --> |战斗| Battle[战斗模式]
CheckCommands --> |鬼市| GhostMarket[鬼市模式]
CheckCommands --> |好友| Friends[好友系统]
CheckCommands --> |其他| GameCmd[游戏指令]
```

**图表来源**
- [LifeHandlerImpl.java](file://Life/src/main/java/com/bot/life/service/impl/LifeHandlerImpl.java#L220-L314)

### handleBattle方法

处理战斗状态，管理战斗流程：

- **状态设置**：设置gameMode=BATTLE
- **战斗初始化**：创建BattleContext
- **战斗循环**：处理玩家和怪物回合
- **结果处理**：胜利、失败或逃跑

**章节来源**
- [LifeHandlerImpl.java](file://Life/src/main/java/com/bot/life/service/impl/LifeHandlerImpl.java#L1076-L1086)

## 状态持久化策略

### 数据库映射

状态数据通过MyBatis ORM框架持久化到数据库：

```mermaid
erDiagram
LIFE_GAME_STATUS {
bigint id PK
varchar user_id
integer game_mode
varchar current_menu
longvarchar context_data
timestamp create_time
timestamp update_time
}
LIFE_PLAYER {
bigint id PK
varchar user_id FK
varchar nickname
integer level
integer health
integer stamina
}
LIFE_BATTLE_STATE {
bigint id PK
bigint player_id FK
integer monster_hp
integer monster_max_hp
integer current_turn
integer battle_type
timestamp create_time
timestamp update_time
}
LIFE_GAME_STATUS ||--|| LIFE_PLAYER : "关联"
LIFE_GAME_STATUS ||--o| LIFE_BATTLE_STATE : "管理"
```

**图表来源**
- [LifeGameStatusMapper.xml](file://Life/src/main/resources/mapper/LifeGameStatusMapper.xml#L5-L13)

### 持久化操作

| 操作类型 | 方法 | 描述 | 触发时机 |
|----------|------|------|----------|
| 查询 | selectByUserId | 根据用户ID获取状态 | 每次状态检查 |
| 创建 | insert | 新建游戏状态记录 | 用户首次进入游戏 |
| 更新 | updateByPrimaryKey | 更新状态信息 | 状态变更时 |
| 删除 | deleteByPlayerId | 删除战斗状态 | 战斗结束后 |

**章节来源**
- [LifeGameStatusMapper.java](file://Life/src/main/java/com/bot/life/dao/mapper/LifeGameStatusMapper.java#L29-L34)

## 数据同步机制

### 上下文数据管理

系统使用contextData字段存储动态的、结构化的上下文信息：

```mermaid
classDiagram
class BattleContext {
+LifePlayer player
+LifeMonster monster
+LifePlayer[] teammates
+Integer currentRound
+String battleId
+Integer battleType
+Map~String,BattleEffect~ playerEffects
+Map~String,BattleEffect~ monsterEffects
+Boolean isPlayerTurn
+Boolean battleEnded
+Boolean playerWin
+StringBuilder battleLog
+addLog(String) void
+getBattleLog() String
}
class ContextData {
<<interface>>
+String serialize()
+void deserialize(String)
+void clear()
}
BattleContext ..|> ContextData : 实现
```

**图表来源**
- [BattleContext.java](file://Life/src/main/java/com/bot/life/dto/BattleContext.java#L14-L54)

### 同步策略

1. **实时同步**：状态变更立即写入数据库
2. **事务保证**：使用数据库事务确保数据一致性
3. **缓存更新**：及时更新内存缓存
4. **异常恢复**：提供状态恢复机制

**章节来源**
- [LifeHandlerImpl.java](file://Life/src/main/java/com/bot/life/service/impl/LifeHandlerImpl.java#L831-L841)

## 状态转换图

### 完整状态转换图

```mermaid
stateDiagram-v2
[*] --> NOT_ENTERED : 用户输入"浮生卷"
NOT_ENTERED --> PREPARE : 用户确认进入
NOT_ENTERED --> NOT_ENTERED : 用户取消或发送其他内容
PREPARE --> IN_GAME : 用户发送"1"
PREPARE --> NOT_ENTERED : 用户发送其他内容
IN_GAME --> BATTLE : 用户发起战斗
IN_GAME --> GHOST_MARKET : 用户访问鬼市
IN_GAME --> IN_GAME : 用户执行其他功能
BATTLE --> IN_GAME : 战斗结束胜利/失败/逃跑
BATTLE --> BATTLE : 战斗进行中
GHOST_MARKET --> IN_GAME : 用户退出鬼市
GHOST_MARKET --> GHOST_MARKET : 用户在鬼市内操作
IN_GAME --> NOT_ENTERED : 用户发送"退出"
NOT_ENTERED --> [*] : 游戏结束
```

### 转换路径说明

| 起始状态 | 目标状态 | 触发条件 | 数据变更 |
|----------|----------|----------|----------|
| NOT_ENTERED | PREPARE | 用户确认进入 | gameMode=1, updateTime |
| PREPARE | IN_GAME | 用户确认 | gameMode=2, 角色检查 |
| IN_GAME | BATTLE | 发起战斗 | gameMode=4, 战斗状态创建 |
| BATTLE | IN_GAME | 战斗结束 | gameMode=2, 战斗状态清理 |
| IN_GAME | GHOST_MARKET | 访问鬼市 | gameMode=3, 地图位置更新 |
| GHOST_MARKET | IN_GAME | 退出鬼市 | gameMode=2, 地图位置恢复 |

## 开发者指南

### 安全的状态变更

1. **状态验证**：每次状态变更前验证当前状态
2. **事务处理**：使用数据库事务确保原子性
3. **异常处理**：提供完善的异常处理机制
4. **状态回滚**：实现状态回滚功能

### 扩展新游戏模式

添加新的游戏模式步骤：

1. **枚举扩展**：在ENGameMode中添加新状态
2. **处理方法**：实现对应的处理方法
3. **状态转换**：添加状态转换逻辑
4. **测试验证**：编写单元测试

### 状态异常处理

```java
// 示例：状态异常处理
private String handleStateException(String userId, ENGameMode currentMode) {
    try {
        // 尝试恢复状态
        LifeGameStatus gameStatus = getOrCreateGameStatus(userId);
        gameStatus.setGameMode(ENGameMode.NOT_ENTERED.getCode());
        gameStatusMapper.updateByPrimaryKey(gameStatus);
        return "游戏状态异常，已自动恢复";
    } catch (Exception e) {
        logger.error("状态恢复失败", e);
        return "游戏状态异常，请重新进入";
    }
}
```

### 最佳实践

1. **单一职责**：每个状态处理方法只负责一种状态
2. **状态隔离**：避免不同状态之间的直接依赖
3. **数据一致性**：确保状态变更的原子性
4. **性能优化**：合理使用缓存减少数据库访问

## 故障排除

### 常见问题

| 问题类型 | 症状 | 可能原因 | 解决方案 |
|----------|------|----------|----------|
| 状态丢失 | 用户状态重置 | 数据库连接异常 | 检查数据库连接，重启服务 |
| 状态冲突 | 并发状态异常 | 多线程并发访问 | 使用锁机制或乐观锁 |
| 数据不一致 | 状态与实际不符 | 异常中断导致 | 实现状态校验和恢复机制 |
| 性能问题 | 状态切换缓慢 | 数据库查询慢 | 优化查询，增加索引 |

### 调试技巧

1. **日志记录**：详细记录状态变更日志
2. **状态监控**：监控状态转换频率和时长
3. **数据验证**：定期验证状态数据完整性
4. **异常捕获**：捕获并记录状态异常

### 维护建议

1. **定期备份**：定期备份游戏状态数据
2. **性能监控**：监控状态管理的性能指标
3. **版本兼容**：确保状态数据的版本兼容性
4. **容量规划**：根据用户增长规划存储容量

**章节来源**
- [LifeHandlerImpl.java](file://Life/src/main/java/com/bot/life/service/impl/LifeHandlerImpl.java#L1738-L1759)