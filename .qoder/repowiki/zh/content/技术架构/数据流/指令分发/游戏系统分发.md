# 游戏系统指令分发文档

<cite>
**本文档引用的文件**
- [DistributorServiceImpl.java](file://Base/src/main/java/com/bot/base/service/impl/DistributorServiceImpl.java)
- [WorkManager.java](file://Base/src/main/java/com/bot/base/service/WorkManager.java)
- [LifeHandlerImpl.java](file://Life/src/main/java/com/bot/life/service/impl/LifeHandlerImpl.java)
- [ENUserGameStatus.java](file://Common/src/main/java/com/bot/common/enums/ENUserGameStatus.java)
- [ENGameMode.java](file://Life/src\main\java\com\bot\life\enums\ENGameMode.java)
- [BaseConsts.java](file://Common/src\main\java\com\bot\common\constant\BaseConsts.java)
- [LifeGameStatus.java](file://Life\src\main\java\com\bot\life\dao\entity\LifeGameStatus.java)
- [AutoTask.java](file://Base\src\main\java\com\bot\base\task\AutoTask.java)
</cite>

## 目录
1. [概述](#概述)
2. [系统架构](#系统架构)
3. [核心组件分析](#核心组件分析)
4. [游戏模式状态管理](#游戏模式状态管理)
5. [指令分发流程](#指令分发流程)
6. [浮生卷游戏模式详解](#浮生卷游戏模式详解)
7. [山海见闻游戏状态](#山海见闻游戏状态)
8. [工作模式管理](#工作模式管理)
9. [状态转换图](#状态转换图)
10. [开发者指南](#开发者指南)
11. [故障排除](#故障排除)

## 概述

DistributorServiceImpl是游戏系统指令分发的核心组件，负责管理多种游戏模式的状态转换和指令路由。该系统支持三种主要的游戏模式：浮生卷修仙游戏、山海见闻文字冒险游戏和工作核算模式。通过LIFE_GAME_TOKENS和GAME_TOKENS两个状态映射表，系统实现了精确的用户状态跟踪和模式切换控制。

## 系统架构

```mermaid
graph TB
subgraph "指令分发层"
DS[DistributorServiceImpl]
CM[Collector]
end
subgraph "游戏处理器层"
LH[LifeHandler]
GH[GameHandler]
WM[WorkManager]
end
subgraph "状态管理层"
LT[LIFE_GAME_TOKENS]
GT[GAME_TOKENS]
WT[WORK_TOKENS]
end
subgraph "游戏模式"
FG[浮生卷游戏]
SG[山海见闻游戏]
WG[工作模式]
end
DS --> LH
DS --> GH
DS --> WM
DS --> CM
LH --> FG
GH --> SG
WM --> WG
DS --> LT
DS --> GT
DS --> WT
```

**图表来源**
- [DistributorServiceImpl.java](file://Base/src/main/java/com/bot/base/service/impl/DistributorServiceImpl.java#L41-L95)
- [WorkManager.java](file://Base/src/main/java/com/bot/base/service/WorkManager.java#L29-L31)

## 核心组件分析

### DistributorServiceImpl核心字段

系统维护了三个关键的状态映射表：

1. **LIFE_GAME_TOKENS**: 浮生卷游戏模式状态映射
2. **GAME_TOKENS**: 山海见闻游戏模式状态映射  
3. **WORK_TOKENS**: 工作模式用户集合

```mermaid
classDiagram
class DistributorServiceImpl {
-Map~String,String~ GAME_TOKENS
-Map~String,String~ LIFE_GAME_TOKENS
-Map~String,String[]~ TEMP_CHAT_RECORD
-Map~String,String[]~ BOT_SEND_RECORD
+doDistributeWithString(reqContent, token, groupId, at, mustRespFlag, channel, withoutPexContent) CommonResp
+req2Resp(reqContent, token, groupId, at, mustRespFlag, channel) CommonResp
-checkUserStatus(activeId) String
-getResponseByKey(keyword) String
}
class WorkManager {
+String[] WORK_TOKENS
+CopyOnWriteArrayList~String~ WAIT_DEAL_DATA_LIST
+entryWork(token) String
+doWork(content, token) CommonResp
}
class LifeHandler {
+play(reqContent, userId) String
+exit(userId) String
-handleGameEntry(reqContent, userId, gameStatus) String
-handlePrepareMode(reqContent, userId, gameStatus) String
-handleInGameMode(reqContent, userId, gameStatus) String
}
DistributorServiceImpl --> WorkManager
DistributorServiceImpl --> LifeHandler
```

**图表来源**
- [DistributorServiceImpl.java](file://Base/src/main/java/com/bot/base/service/impl/DistributorServiceImpl.java#L94-L95)
- [WorkManager.java](file://Base/src/main/java/com/bot/base/service/WorkManager.java#L29-L31)

**章节来源**
- [DistributorServiceImpl.java](file://Base/src/main/java/com/bot/base/service/impl/DistributorServiceImpl.java#L94-L95)
- [WorkManager.java](file://Base/src/main/java/com/bot/base/service/WorkManager.java#L29-L31)

## 游戏模式状态管理

### 浮生卷游戏状态映射

浮生卷游戏采用三层状态管理模式：

```mermaid
stateDiagram-v2
[*] --> 未进入
未进入 --> 预备状态 : 发送"浮生卷"
预备状态 --> 未进入 : 发送其他内容
预备状态 --> 正式游戏 : 发送"1"
正式游戏 --> 未进入 : 发送"退出"
正式游戏 --> 鬼市模式 : 进入鬼市
正式游戏 --> 战斗模式 : 遭遇怪物
鬼市模式 --> 正式游戏 : 结束鬼市
战斗模式 --> 正式游戏 : 战斗结束
```

**图表来源**
- [LifeHandlerImpl.java](file://Life/src/main/java/com/bot/life/service/impl/LifeHandlerImpl.java#L157-L165)
- [ENGameMode.java](file://Life/src/main/java/com/bot/life/enums/ENGameMode.java#L8-L12)

### 山海见闻游戏状态映射

山海见闻游戏采用两阶段确认模式：

```mermaid
stateDiagram-v2
[*] --> 未加入
未加入 --> 等待加入 : 发送"游戏"
等待加入 --> 未加入 : 发送"0"
等待加入 --> 已加入 : 发送"1"
已加入 --> 未加入 : 发送"退出"
```

**图表来源**
- [DistributorServiceImpl.java](file://Base/src/main/java/com/bot/base/service/impl/DistributorServiceImpl.java#L288-L306)
- [ENUserGameStatus.java](file://Common/src/main/java/com/bot/common/enums/ENUserGameStatus.java#L14-L15)

### 工作模式状态映射

工作模式采用简单的一次性激活模式：

```mermaid
stateDiagram-v2
[*] --> 未激活
未激活 --> 激活中 : 发送"开始核算"
激活中 --> 未激活 : 发送"退出"
激活中 --> 文件导出 : 发送"结束"
```

**图表来源**
- [WorkManager.java](file://Base/src/main/java/com/bot/base/service/WorkManager.java#L51-L64)

**章节来源**
- [LifeHandlerImpl.java](file://Life/src/main/java/com/bot/life/service/impl/LifeHandlerImpl.java#L157-L165)
- [ENGameMode.java](file://Life/src/main/java/com/bot/life/enums/ENGameMode.java#L8-L12)
- [ENUserGameStatus.java](file://Common/src/main/java/com/bot/common/enums/ENUserGameStatus.java#L14-L15)

## 指令分发流程

### 主要分发逻辑

系统按照优先级顺序处理指令：

```mermaid
flowchart TD
Start([接收指令]) --> TopToken{顶级Token?}
TopToken --> |是| TopService[顶级服务处理]
TopToken --> |否| SignToken{签到Token?}
SignToken --> |是| SignService[签到服务处理]
SignToken --> |否| Manager{管理模式?}
Manager --> |是| SystemManager[系统管理处理]
Manager --> |否| UserBox[用户盒子处理]
UserBox --> RegPrefix{注册前缀?}
RegPrefix --> |是| RegService[注册服务处理]
RegPrefix --> |否| UserStatus{用户状态检查}
UserStatus --> |异常| StatusError[状态错误响应]
UserStatus --> |正常| GameCheck{游戏模式检查}
GameCheck --> |浮生卷| LifeGame[浮生卷游戏处理]
GameCheck --> |山海见闻| StandardGame[标准游戏处理]
GameCheck --> |工作模式| WorkMode[工作模式处理]
WorkMode --> WorkService[工作服务处理]
StandardGame --> GameService[游戏服务处理]
LifeGame --> LifeService[生命游戏服务处理]
TopService --> Response[返回响应]
SignService --> Response
SystemManager --> Response
StatusError --> Response
WorkService --> Response
GameService --> Response
LifeService --> Response
```

**图表来源**
- [DistributorServiceImpl.java](file://Base/src/main/java/com/bot/base/service/impl/DistributorServiceImpl.java#L216-L360)

### 浮生卷游戏指令处理流程

```mermaid
sequenceDiagram
participant User as 用户
participant DS as Distributor
participant LH as LifeHandler
participant DB as 数据库
User->>DS : 发送"浮生卷"
DS->>DS : 检查LIFE_GAME_TOKENS
DS->>LH : 调用play("浮生卷", token)
LH->>DB : 获取游戏状态
LH->>LH : 设置PREPARE状态
LH->>LH : 生成欢迎图片
LH-->>DS : 返回图片路径
DS-->>User : 发送欢迎图片
User->>DS : 发送"1"
DS->>DS : 检查LIFE_GAME_TOKENS
DS->>LH : 调用play("1", token)
LH->>DB : 更新为IN_GAME状态
LH->>LH : 检查角色是否存在
alt 角色不存在
LH->>LH : 显示角色创建界面
else 角色存在
LH->>LH : 显示主菜单
end
LH-->>DS : 返回处理结果
DS-->>User : 发送游戏界面
```

**图表来源**
- [DistributorServiceImpl.java](file://Base/src/main/java/com/bot/base/service/impl/DistributorServiceImpl.java#L270-L285)
- [LifeHandlerImpl.java](file://Life/src/main/java/com/bot/life/service/impl/LifeHandlerImpl.java#L174-L218)

**章节来源**
- [DistributorServiceImpl.java](file://Base/src/main/java/com/bot/base/service/impl/DistributorServiceImpl.java#L216-L360)
- [LifeHandlerImpl.java](file://Life/src/main/java/com/bot/life/service/impl/LifeHandlerImpl.java#L174-L218)

## 浮生卷游戏模式详解

### 进入流程

浮生卷游戏的进入遵循严格的三阶段流程：

1. **游戏名确认阶段**: 用户发送"浮生卷"触发游戏模式
2. **预备状态阶段**: 系统提示用户发送"1"正式进入
3. **正式游戏阶段**: 用户创建角色或加载现有角色

### 角色创建规范

系统要求角色创建包含以下信息：
- **昵称**: 中文字符，不超过7个字
- **派系**: 金、木、水、火、土五种选择
- **特色提示**: 系统提供各派系的属性特点说明

### 游戏状态转换

```mermaid
flowchart LR
A[未进入] --> B[预备状态]
B --> C[正式游戏]
C --> D[鬼市模式]
C --> E[战斗模式]
D --> C
E --> C
C --> A
B --> A
```

**图表来源**
- [LifeHandlerImpl.java](file://Life/src/main/java/com/bot/life/service/impl/LifeHandlerImpl.java#L174-L218)

**章节来源**
- [LifeHandlerImpl.java](file://Life/src/main/java/com/bot/life/service/impl/LifeHandlerImpl.java#L174-L218)

## 山海见闻游戏状态

### 停用状态处理

山海见闻游戏已进入无限期停止状态，系统在检测到相关指令时返回停用提示：

```mermaid
flowchart TD
A[接收游戏指令] --> B{指令类型}
B --> |发送"游戏"| C[返回停用提示]
B --> |其他指令| D[继续处理]
C --> E[提示游戏已停用]
D --> F[执行其他功能]
```

**图表来源**
- [DistributorServiceImpl.java](file://Base/src/main/java/com/bot/base/service/impl/DistributorServiceImpl.java#L308-L314)

### 边界情况处理

系统对山海见闻游戏的停用进行了优雅的处理，避免了功能异常：

- **指令拦截**: 直接返回停用提示
- **状态清理**: 保留原有状态映射结构
- **用户体验**: 提供友好的替代方案

**章节来源**
- [DistributorServiceImpl.java](file://Base/src/main/java/com/bot/base/service/impl/DistributorServiceImpl.java#L308-L314)

## 工作模式管理

### 激活机制

工作模式采用一次性激活机制：

```mermaid
sequenceDiagram
participant User as 用户
participant WM as WorkManager
participant FS as 文件系统
participant EX as Excel处理
User->>WM : 发送"开始核算"
WM->>FS : 检查Excel文件是否存在
alt 文件不存在
WM->>FS : 创建新Excel文件
WM->>EX : 填充日期模板
end
WM->>WM : 添加用户到WORK_TOKENS
WM-->>User : 返回激活成功提示
```

**图表来源**
- [WorkManager.java](file://Base/src/main/java/com/bot/base/service/WorkManager.java#L51-L64)

### 数据收集与处理

工作模式支持实时数据收集和批量处理：

```mermaid
flowchart TD
A[用户输入] --> B{指令类型}
B --> |普通文本| C[添加到WAIT_DEAL_DATA_LIST]
B --> |退出| D[移除用户TOKEN]
B --> |结束| E[导出Excel文件]
B --> |提取| F[提取统计数据]
B --> |处理| G[启动后台处理]
C --> H[返回收集确认]
D --> I[返回退出成功]
E --> J[返回文件链接]
F --> K[返回统计结果]
G --> L[异步处理数据]
```

**图表来源**
- [WorkManager.java](file://Base/src/main/java/com/bot/base/service/WorkManager.java#L72-L93)

### 自动清理机制

系统实现了定时自动清理机制：

```mermaid
flowchart TD
A[定时任务启动] --> B[检查当前时间]
B --> C{是否凌晨0:30?}
C --> |是| D[清空WORK_TOKENS]
C --> |否| E[等待30分钟]
D --> F[清空WAIT_DEAL_DATA_LIST]
F --> G[任务结束]
E --> B
```

**图表来源**
- [AutoTask.java](file://Base/src/main/java/com/bot/base/task/AutoTask.java#L20-L38)

**章节来源**
- [WorkManager.java](file://Base/src/main/java/com/bot/base/service/WorkManager.java#L51-L93)
- [AutoTask.java](file://Base/src/main/java/com/bot/base/task/AutoTask.java#L20-L38)

## 状态转换图

### 完整游戏系统状态图

```mermaid
stateDiagram-v2
[*] --> 正常模式
--正常模式--
正常模式 --> 浮生卷游戏 : 发送"浮生卷"
正常模式 --> 山海见闻游戏 : 发送"游戏"(已停用)
正常模式 --> 工作模式 : 发送"开始核算"
正常模式 --> 管理模式 : 发送"进入管理模式"
--浮生卷游戏--
浮生卷游戏 --> 预备状态 : 接收游戏名
预备状态 --> 正式游戏 : 发送"1"
预备状态 --> 正常模式 : 发送其他内容
正式游戏 --> 鬼市模式 : 进入鬼市
正式游戏 --> 战斗模式 : 遭遇怪物
正式游戏 --> 正常模式 : 发送"退出"
鬼市模式 --> 正式游戏 : 结束鬼市
战斗模式 --> 正式游戏 : 战斗结束
--山海见闻游戏--
山海见闻游戏 --> 等待加入 : 发送"游戏"
等待加入 --> 正常模式 : 发送"0"
等待加入 --> 已加入 : 发送"1"
已加入 --> 正常模式 : 发送"退出"
--工作模式--
工作模式 --> 数据收集 : 输入核算信息
数据收集 --> 数据收集 : 继续输入
数据收集 --> 文件导出 : 发送"结束"
数据收集 --> 正常模式 : 发送"退出"
文件导出 --> 正常模式 : 完成处理
--管理模式--
管理模式 --> 管理功能 : 管理指令
管理功能 --> 管理功能 : 继续管理
管理功能 --> 正常模式 : 发送"退出管理模式"
```

**图表来源**
- [DistributorServiceImpl.java](file://Base/src/main/java/com/bot/base/service/impl/DistributorServiceImpl.java#L216-L360)
- [LifeHandlerImpl.java](file://Life/src/main/java/com/bot/life/service/impl/LifeHandlerImpl.java#L157-L165)

## 开发者指南

### 实现新游戏模式

要实现新的游戏模式，需要遵循以下步骤：

1. **扩展状态枚举**:
```java
// 在ENGameMode中添加新状态
public enum ENGameMode {
    NEW_GAME_MODE(5, "新游戏模式"),
    // ...
}
```

2. **实现处理器接口**:
```java
public interface NewGameHandler {
    String play(String reqContent, String userId);
    String exit(String userId);
    String manage(String reqContent);
}
```

3. **集成到分发器**:
```java
// 在DistributorServiceImpl中添加处理逻辑
if (NEW_GAME_TOKENS.containsKey(token)) {
    return new CommonResp(newGameHandler.play(reqContent, token), ENRespType.TEXT.getType());
}
```

### 管理游戏状态

使用以下模式管理游戏状态：

```java
// 状态检查和转换
public String handleGameState(String reqContent, String userId, GameStatus status) {
    ENGameMode currentMode = ENGameMode.getByCode(status.getGameMode());
    
    switch (currentMode) {
        case NOT_ENTERED:
            return handleNotEntered(reqContent, userId, status);
        case IN_GAME:
            return handleInGame(reqContent, userId, status);
        // ...
    }
}
```

### 处理模式切换边界情况

实现健壮的边界情况处理：

```java
// 状态验证和恢复
public String safeHandleGame(String reqContent, String userId) {
    try {
        GameStatus status = getOrCreateGameStatus(userId);
        // 验证状态有效性
        if (status == null || !isValidStatus(status)) {
            resetToNormalMode(userId);
            return "游戏状态异常，已重置为正常模式";
        }
        return processGameRequest(reqContent, userId, status);
    } catch (Exception e) {
        log.error("游戏处理异常: {}", userId, e);
        resetToNormalMode(userId);
        return "发生异常，已重置为正常模式";
    }
}
```

### 最佳实践

1. **状态持久化**: 使用数据库保存游戏状态
2. **异常处理**: 实现完善的异常捕获和恢复机制
3. **资源清理**: 确保状态转换时正确清理资源
4. **并发安全**: 使用适当的同步机制处理并发访问
5. **用户体验**: 提供清晰的状态反馈和错误提示

## 故障排除

### 常见问题及解决方案

#### 1. 游戏状态丢失
**症状**: 用户发送指令后无响应或状态异常
**原因**: 状态映射表数据丢失或内存溢出
**解决方案**: 
- 检查状态映射表初始化
- 实现状态持久化机制
- 添加状态恢复逻辑

#### 2. 模式切换冲突
**症状**: 多个游戏模式同时激活
**原因**: 状态检查逻辑不完整
**解决方案**:
```java
// 添加互斥检查
public boolean canEnterNewGame(String userId, String newGameType) {
    return !LIFE_GAME_TOKENS.containsKey(userId) && 
           !GAME_TOKENS.containsKey(userId) && 
           !WorkManager.WORK_TOKENS.contains(userId);
}
```

#### 3. 工作模式数据丢失
**症状**: 用户退出后数据无法找回
**原因**: 数据收集列表未持久化
**解决方案**:
```java
// 实现数据持久化
public void persistWorkData(String userId, String data) {
    // 保存到数据库或文件系统
    workDataManager.saveUserData(userId, data);
}
```

#### 4. 状态超时处理
**症状**: 用户长时间不操作导致状态混乱
**解决方案**:
```java
// 添加超时检查
public boolean isStateValid(GameStatus status) {
    long minutesSinceLastActivity = TimeUnit.MILLISECONDS.toMinutes(
        System.currentTimeMillis() - status.getLastActivityTime().getTime()
    );
    return minutesSinceLastActivity < MAX_INACTIVE_MINUTES;
}
```

### 调试工具

1. **状态监控**: 实现状态查询接口
2. **日志记录**: 添加详细的调试日志
3. **性能监控**: 监控状态转换性能
4. **异常追踪**: 实现异常堆栈追踪

通过遵循本文档的指导原则和最佳实践，开发者可以有效地扩展和维护游戏系统的指令分发功能，确保系统的稳定性和用户体验。