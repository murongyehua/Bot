# 定期清理

<cite>
**本文档引用文件**   
- [Life_Deployment_Guide.md](file://Life_Deployment_Guide.md)
- [Life_Database_Init.sql](file://Life_Database_Init.sql)
</cite>

## 目录
1. [引言](#引言)
2. [清理策略概述](#清理策略概述)
3. [临时数据清理](#临时数据清理)
4. [过期记录清理](#过期记录清理)
5. [历史数据归档](#历史数据归档)
6. [自动化脚本配置](#自动化脚本配置)
7. [风险控制与最佳实践](#风险控制与最佳实践)
8. [维护建议](#维护建议)

## 引言

本文档旨在为Bot项目中的浮生卷模块提供一套完整的数据库定期清理方案。基于《Life_Deployment_Guide.md》中的维护建议和《Life_Database_Init.sql》中定义的`life_temp_files`表结构，本文档详细说明了如何清理数据库中的临时数据和过期记录，包括具体的SQL脚本、清理频率、自动化配置以及操作风险控制措施。

数据库的健康运行对于游戏服务的稳定性和性能至关重要。随着用户活动的持续进行，系统会不断产生临时文件记录、游戏状态信息和历史数据。若不及时清理，这些数据将占用大量存储空间，影响查询性能，并可能导致系统响应变慢。因此，建立科学的定期清理机制是运维工作的重要组成部分。

本文档的目标是帮助运维团队理解并实施有效的数据库维护策略，确保浮生卷模块的数据库始终保持整洁、高效和可靠。

## 清理策略概述

根据《Life_Deployment_Guide.md》的维护建议，数据库清理工作主要围绕三类数据展开：临时文件、过期的游戏状态和需要归档的历史数据。清理策略的核心是“定期执行、自动化运行、安全可控”。

### 清理目标

1.  **清理过期临时文件记录**：移除`life_temp_files`表中已过期的记录，释放数据库空间。
2.  **清除无效游戏状态**：清理`life_game_status`等表中长时间未更新的无效会话，避免状态混乱。
3.  **归档历史数据**：将`life_world_boss_challenge`等表中的历史挑战记录进行归档处理，保留核心数据的同时降低主表压力。

### 清理频率

建议采用分层清理策略：
-   **每日清理**：针对临时文件和短期状态数据，建议每天执行一次。
-   **每周归档**：针对历史挑战记录等数据，建议每周进行一次归档。
-   **每月维护**：进行全面的数据库检查、索引优化和完整性验证。

**Section sources**
- [Life_Deployment_Guide.md](file://Life_Deployment_Guide.md#L172-L184)

## 临时数据清理

临时数据主要指那些为特定操作（如图片生成）而创建，且在一定时间后失去价值的数据。在浮生卷模块中，`life_temp_files`表是这类数据的典型代表。

### life_temp_files 表结构分析

根据`Life_Database_Init.sql`脚本，`life_temp_files`表的结构如下：

| 字段名 | 数据类型 | 默认值 | 说明 |
| :--- | :--- | :--- | :--- |
| `id` | bigint | 自增 | 主键ID |
| `file_path` | varchar(255) | 无 | 文件路径 |
| `create_time` | datetime | CURRENT_TIMESTAMP | 创建时间 |
| `expire_time` | datetime | DATE_ADD(CURRENT_TIMESTAMP, INTERVAL 1 DAY) | 过期时间 |

该表的设计非常清晰，`expire_time`字段默认设置为创建时间后的24小时，这为自动化清理提供了明确的判断依据。

### 清理SQL脚本

清理过期临时文件的SQL脚本非常简单直接，利用`expire_time`字段进行判断：

```sql
-- 清理过期临时文件记录
DELETE FROM life_temp_files WHERE expire_time < NOW();
```

此脚本将删除所有过期时间早于当前时间的记录，确保数据库中只保留有效的临时文件信息。

**Section sources**
- [Life_Database_Init.sql](file://Life_Database_Init.sql#L636-L642)
- [Life_Deployment_Guide.md](file://Life_Deployment_Guide.md#L175-L176)

## 过期记录清理

除了临时文件，系统在运行过程中还会产生一些临时性的游戏状态记录。这些记录如果长时间不更新，就可能成为“僵尸”数据，占用资源。

### 清理目标

主要清理目标是`life_game_status`表。该表用于存储用户当前的游戏会话状态，如当前菜单、上下文数据等。当用户长时间不活跃或会话异常中断时，其状态记录可能无法被正常清除。

### 清理SQL脚本

可以基于`update_time`字段来清理长时间未更新的状态记录。例如，清理超过7天未更新的记录：

```sql
-- 清理超过7天未更新的游戏状态记录
DELETE FROM life_game_status WHERE update_time < DATE_SUB(NOW(), INTERVAL 7 DAY);
```

此外，`life_battle_state`表也存储了战斗中的临时状态，同样需要清理：

```sql
-- 清理超过1小时未更新的战斗状态记录
DELETE FROM life_battle_state WHERE update_time < DATE_SUB(NOW(), INTERVAL 1 HOUR);
```

**Section sources**
- [Life_Database_Init.sql](file://Life_Database_Init.sql#L379-L389)
- [Life_Database_Init.sql](file://Life_Database_Init.sql#L599-L616)

## 历史数据归档

对于一些具有长期价值但访问频率较低的历史数据，如世界BOSS挑战记录，直接删除会造成数据丢失。更合理的做法是进行归档。

### 归档策略

归档策略通常分为两步：
1.  **数据迁移**：将满足条件的历史数据从主表复制到归档表。
2.  **数据删除**：从主表中删除已归档的数据。

### 归档SQL脚本示例

假设我们有一个名为`life_world_boss_challenge_archive`的归档表，其结构与原表相同。我们可以编写如下脚本：

```sql
-- 开始事务，确保数据一致性
START TRANSACTION;

-- 将30天前的挑战记录插入归档表
INSERT INTO life_world_boss_challenge_archive 
SELECT * FROM life_world_boss_challenge 
WHERE challenge_time < DATE_SUB(NOW(), INTERVAL 30 DAY);

-- 从原表中删除已归档的记录
DELETE FROM life_world_boss_challenge 
WHERE challenge_time < DATE_SUB(NOW(), INTERVAL 30 DAY);

-- 提交事务
COMMIT;
```

此脚本确保了数据迁移和删除的原子性，避免了数据丢失的风险。

**Section sources**
- [Life_Database_Init.sql](file://Life_Database_Init.sql#L558-L569)

## 自动化脚本配置

为了减轻运维负担，所有清理操作都应配置为自动化脚本，通过操作系统的定时任务（如Linux的cron）来执行。

### 脚本示例 (clean_temp_files.sh)

```bash
#!/bin/bash

# 数据库连接信息
DB_HOST="localhost"
DB_PORT="3306"
DB_NAME="bot"
DB_USER="root"
DB_PASS="your_password"

# SQL命令
SQL_COMMAND="DELETE FROM life_temp_files WHERE expire_time < NOW();"

# 执行清理
mysql -h${DB_HOST} -P${DB_PORT} -u${DB_USER} -p${DB_PASS} ${DB_NAME} -e "${SQL_COMMAND}"

# 检查执行结果
if [ $? -eq 0 ]; then
    echo "$(date): 临时文件清理成功"
else
    echo "$(date): 临时文件清理失败"
fi
```

### Cron定时任务配置

将上述脚本添加到crontab中，实现每日自动执行：

```bash
# 每天凌晨1点执行临时文件清理
0 1 * * * /path/to/clean_temp_files.sh >> /var/log/db_clean.log 2>&1

# 每周一凌晨2点执行历史数据归档
0 2 * * 1 /path/to/archive_boss_challenges.sh >> /var/log/db_archive.log 2>&1
```

**Section sources**
- [Life_Deployment_Guide.md](file://Life_Deployment_Guide.md#L175-L176)

## 风险控制与最佳实践

数据库清理操作具有潜在风险，必须谨慎执行。

### 风险控制措施

1.  **备份先行**：在执行任何清理或归档操作前，必须对相关表进行完整备份。
2.  **使用事务**：对于涉及多步操作的归档任务，务必使用数据库事务（`START TRANSACTION` 和 `COMMIT`），确保操作的原子性。
3.  **分批处理**：如果待清理的数据量巨大，应避免一次性删除，采用分批处理（如`LIMIT`子句），防止长时间锁表影响线上服务。
4.  **测试验证**：所有脚本必须先在测试环境中充分验证，确认无误后再部署到生产环境。
5.  **日志记录**：详细记录每次清理操作的时间、执行的SQL、影响的行数和执行结果，便于审计和故障排查。

### 最佳实践

-   **监控清理效果**：定期检查`life_temp_files`等表的大小和记录数，评估清理策略的有效性。
-   **优化过期时间**：根据实际业务需求，合理调整`life_temp_files`表的`expire_time`默认值。
-   **利用数据库特性**：考虑使用MySQL的事件调度器（Event Scheduler）来替代外部脚本，实现更紧密的集成。

**Section sources**
- [Life_Deployment_Guide.md](file://Life_Deployment_Guide.md#L166-L167)

## 维护建议

根据《Life_Deployment_Guide.md》的指导，数据库维护是保障系统长期稳定运行的关键环节。

### 定期维护任务

建议运维团队将以下任务纳入常规维护计划：

```sql
-- 1. 清理过期临时文件记录
DELETE FROM life_temp_files WHERE expire_time < NOW();

-- 2. 检查玩家数据完整性
SELECT COUNT(*) FROM life_player;
SELECT COUNT(*) FROM life_game_status;

-- 3. 分析热门功能
SELECT config_key, config_value FROM life_system_config;
```

### 监控与备份

-   **监控**：持续监控在线玩家数量、数据库连接池状态和内存使用情况。
-   **备份**：定期备份核心数据，包括玩家数据（`life_player`表）、游戏状态（`life_game_status`表）和系统配置（`life_system_config`表）。

遵循这些维护建议，可以有效预防数据膨胀和性能下降，确保浮生卷模块的健康运行。

**Section sources**
- [Life_Deployment_Guide.md](file://Life_Deployment_Guide.md#L172-L184)
- [Life_Deployment_Guide.md](file://Life_Deployment_Guide.md#L186-L192)
- [Life_Deployment_Guide.md](file://Life_Deployment_Guide.md#L194-L199)